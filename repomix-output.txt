This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-20T15:42:33.603Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/
  workflows/
    release.yml
cline_docs/
  activeContext.md
  productContext.md
  progress.md
  systemPatterns.md
  techContext.md
heartbeat/
  heartbeat.go
lights/
  blink1_light.go
  commands.go
  light.go
  serial_light.go
  traffic_light.go
  utils.go
network/
  network.go
node/
  node.go
notify/
  notify.go
poll/
  poll.go
types/
  types.go
.gitignore
.python-version
go.mod
go.sum
light.go
main_test.go
main.go
Makefile
README.md

================================================================
Repository Files
================================================================

================
File: .github/workflows/release.yml
================
name: Release

on:
  push:
    tags:
      - 'v*'

# Add permissions block
permissions:
  contents: write
  packages: write
  actions: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.18'

      - name: Build Release Assets
        run: make release

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            release/my-incident-checker-*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: cline_docs/activeContext.md
================
# Active Context

## Current Task
Implementing a Go console application that sends notifications to ntfy.sh.

## Recent Changes
- Initial project setup

## Next Steps
1. Create go.mod file
2. Implement main.go with notify function
3. Add error handling
4. Test notification delivery

================
File: cline_docs/productContext.md
================
# Product Context

## Purpose
This project is a Go-based console application that sends notifications to ntfy.sh, a pub-sub notification service.

## Problem Statement
The application solves the need for simple, programmatic notification delivery by making HTTP calls to ntfy.sh on startup.

## Expected Behavior
1. Application starts
2. Makes an HTTP POST request to ntfy.sh/dapidi_alerts with the message "Hi"
3. Exits after successful notification delivery or error handling

================
File: cline_docs/progress.md
================
# Progress

## Completed
- Memory Bank documentation setup
- Initial project setup with go.mod
- Core notification functionality to ntfy.sh
- Incident polling and monitoring system
- Error handling and connectivity checks
- Regular heartbeat functionality to nosnch.in

## In Progress
- Testing and monitoring of heartbeat functionality
- Verifying concurrent operations stability

## To Do
1. Monitor system performance
2. Consider adding metrics/logging for heartbeat success rate
3. Consider adding configuration options for intervals

## Status
Project is fully functional with all core features implemented:
- Startup notifications
- Incident polling and alerts
- Regular heartbeat checks
- Concurrent operation handling

================
File: cline_docs/systemPatterns.md
================
# System Patterns

## Architecture
- Console application with concurrent operations
- Multiple responsibilities:
  1. HTTP notification delivery to ntfy.sh
  2. Incident polling and monitoring
  3. Regular heartbeat checks to nosnch.in
- Function-based organization with clear separation of concerns

## Technical Decisions
1. Using net/http package for HTTP requests
   - Standard library provides all needed functionality
   - No external dependencies required
   
2. Error handling pattern
   - Immediate error reporting and exit for critical startup errors
   - Logged errors with continued execution for non-critical operations
   - Clear error messages for debugging

3. Concurrency pattern
   - Goroutines for independent operations
   - Time-based tickers for regular intervals
   - Non-blocking execution of heartbeats

## Code Organization
- main.go: Entry point with multiple concurrent functions:
  - notify: Send notifications to ntfy.sh
  - pollIncidents: Monitor and report incidents
  - sendHeartbeat: Regular health checks to nosnch.in
- Flat structure with modular functions

================
File: cline_docs/techContext.md
================
# Technical Context

## Technologies Used
- Go 1.x
- Standard library packages:
  - net/http for HTTP requests
  - fmt for output
  - log for error logging

## Development Setup
1. Go installation required
2. No external dependencies
3. Built using standard Go tools:
   - go build
   - go run

## Technical Constraints
- Simple HTTP POST request
- Fixed notification endpoint: ntfy.sh/dapidi_alerts
- Fixed message content: "Hi"
- Synchronous execution

================
File: heartbeat/heartbeat.go
================
package heartbeat

import (
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"
)

const (
	heartbeatEndpoint = "https://nosnch.in/2b7bdbea9e"
	heartbeatInterval = 5 * time.Minute
)

// sendHeartbeat sends a heartbeat signal to the monitoring service
func sendHeartbeat() error {
	payload := strings.NewReader("m=just checking in")
	resp, err := http.Post(heartbeatEndpoint, "application/x-www-form-urlencoded", payload)
	if err != nil {
		return fmt.Errorf("failed to send heartbeat:: %s", err.Error())
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		return fmt.Errorf("heartbeat failed with status code: %d", resp.StatusCode)
	}

	return nil
}

// Run continuously sends heartbeat signals at regular intervals
func Run() {
	fmt.Printf("In runHeartbeat\n")
	ticker := time.NewTicker(heartbeatInterval)
	defer ticker.Stop()

	for {
		fmt.Printf("Sending heartbeat\n")
		if err := sendHeartbeat(); err != nil {
			fmt.Printf("Heartbeat error: %s\n", err.Error())
			log.Printf("Heartbeat error:: %s", err.Error())
		}
		<-ticker.C
	}
	fmt.Printf("Exiting runHeartbeat\n")
}

================
File: lights/blink1_light.go
================
package lights

import (
	"fmt"
	"os"
	"path/filepath"
)

const (
	// USB vendor ID and product ID for BLINK1MK3
	blink1VendorID  = "27b8"
	blink1ProductID = "01ed"
)

// Blink1Light implements Light interface for BLINK1MK3
type Blink1Light struct {
	devicePath string
	isOn       bool
	isBlinking bool
	current    StandardState
}

// NewBlink1Light creates a new Blink1Light instance
func NewBlink1Light() (*Blink1Light, error) {
	// Check for blink1 device in /sys/bus/usb/devices/
	// This is a Linux-specific implementation that looks for USB devices
	devicePath, err := findBlink1Device()
	if err != nil {
		return nil, fmt.Errorf("BLINK1MK3 not available: %w", err)
	}

	return &Blink1Light{
		devicePath: devicePath,
		isOn:       false,
		isBlinking: false,
		current:    StateOff,
	}, nil
}

// findBlink1Device searches for a BLINK1MK3 device in the system
func findBlink1Device() (string, error) {
	// Walk through USB devices in sysfs
	var devicePath string
	err := filepath.Walk("/sys/bus/usb/devices", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip if not a directory
		if !info.IsDir() {
			return nil
		}

		// Check vendor ID
		vendorPath := filepath.Join(path, "idVendor")
		if vendor, err := os.ReadFile(vendorPath); err == nil {
			if string(vendor[:4]) == blink1VendorID {
				// Check product ID
				productPath := filepath.Join(path, "idProduct")
				if product, err := os.ReadFile(productPath); err == nil {
					if string(product[:4]) == blink1ProductID {
						devicePath = path
						return filepath.SkipDir // Stop traversing this directory
					}
				}
			}
		}
		return nil
	})

	if err != nil {
		return "", fmt.Errorf("error searching for device: %w", err)
	}

	if devicePath == "" {
		return "", fmt.Errorf("no BLINK1MK3 device found")
	}

	return devicePath, nil
}

// On turns on the light with a steady state
func (l *Blink1Light) On(cmd interface{}) error {
	state, ok := cmd.(StandardState)
	if !ok {
		return fmt.Errorf("invalid command type for Blink1Light")
	}

	// For now, just track the state since we don't have direct USB control implemented
	l.isOn = true
	l.isBlinking = false
	l.current = state
	return nil
}

// Blink turns on the light with a blinking state
func (l *Blink1Light) Blink(cmd interface{}) error {
	state, ok := cmd.(StandardState)
	if !ok {
		return fmt.Errorf("invalid command type for Blink1Light")
	}

	// For now, just track the state since we don't have direct USB control implemented
	l.isOn = true
	l.isBlinking = true
	l.current = state
	return nil
}

// Clear turns off the light and resets all states
func (l *Blink1Light) Clear() error {
	l.isOn = false
	l.isBlinking = false
	l.current = StateOff
	return nil
}

// Close cleans up resources by clearing the light state
func (l *Blink1Light) Close() {
	l.Clear()
}

================
File: lights/commands.go
================
package lights

// Command bytes for LEDs and buzzer
const (
	cmdRedOn    byte = 0x11
	cmdRedOff   byte = 0x21
	cmdRedBlink byte = 0x41

	cmdYellowOn    byte = 0x12
	cmdYellowOff   byte = 0x22
	cmdYellowBlink byte = 0x42

	cmdGreenOn    byte = 0x14
	cmdGreenOff   byte = 0x24
	cmdGreenBlink byte = 0x44

	cmdBuzzerOn    byte = 0x18
	cmdBuzzerOff   byte = 0x28
	cmdBuzzerBlink byte = 0x48
)

================
File: lights/light.go
================
package lights

// State represents the possible states of a light
type State interface {
	Apply(light Light) error
}

// Light defines the interface for different light implementations
type Light interface {
	// On turns on a specific light state
	On(cmd interface{}) error
	// Clear turns off all lights
	Clear() error
	// Blink makes a light blink
	Blink(cmd interface{}) error
}

// StandardState represents common light states
type StandardState string

const (
	StateRed    StandardState = "red"
	StateYellow StandardState = "yellow"
	StateGreen  StandardState = "green"
	StateOff    StandardState = "off"
)

// RedState implements State
type RedState struct{}

func (s RedState) Apply(light Light) error {
	return light.On(StateRed)
}

// YellowState implements State
type YellowState struct{}

func (s YellowState) Apply(light Light) error {
	return light.On(StateYellow)
}

// GreenState implements State
type GreenState struct{}

func (s GreenState) Apply(light Light) error {
	return light.On(StateGreen)
}

// BlinkingRedState implements State for blinking red light
type BlinkingRedState struct{}

func (s BlinkingRedState) Apply(light Light) error {
	return light.Blink(StateRed)
}

// BlinkingYellowState implements State for blinking yellow light
type BlinkingYellowState struct{}

func (s BlinkingYellowState) Apply(light Light) error {
	return light.Blink(StateYellow)
}

// BlinkingGreenState implements State for blinking green light
type BlinkingGreenState struct{}

func (s BlinkingGreenState) Apply(light Light) error {
	return light.Blink(StateGreen)
}

================
File: lights/serial_light.go
================
package lights

import (
	"fmt"
	"log"

	"github.com/tarm/serial"
)

// SerialLight implements Light interface for serial-based tower lights
type SerialLight struct {
	port     string
	baudRate int
}

// NewSerialLight creates a new SerialLight instance
func NewSerialLight(port string, baudRate int) *SerialLight {
	return &SerialLight{
		port:     port,
		baudRate: baudRate,
	}
}

func (l *SerialLight) openPort() (*serial.Port, error) {
	c := &serial.Config{
		Name: l.port,
		Baud: l.baudRate,
	}
	return serial.OpenPort(c)
}

func (l *SerialLight) On(cmd interface{}) error {
	state, ok := cmd.(StandardState)
	if !ok {
		return fmt.Errorf("invalid command type for SerialLight")
	}

	var cmdByte byte
	switch state {
	case StateRed:
		cmdByte = cmdRedOn
	case StateYellow:
		cmdByte = cmdYellowOn
	case StateGreen:
		cmdByte = cmdGreenOn
	default:
		return fmt.Errorf("unsupported state: %s", state)
	}

	if err := l.Clear(); err != nil {
		return fmt.Errorf("failed to clear light state: %w", err)
	}

	s, err := l.openPort()
	if err != nil {
		return err
	}
	defer func() {
		if err := s.Close(); err != nil {
			log.Printf("Error closing serial port: %s", err.Error())
		}
	}()

	return sendCommand(s, cmdByte)
}

func (l *SerialLight) Blink(cmd interface{}) error {
	state, ok := cmd.(StandardState)
	if !ok {
		return fmt.Errorf("invalid command type for SerialLight")
	}

	var cmdByte byte
	switch state {
	case StateRed:
		cmdByte = cmdRedBlink
	case StateYellow:
		cmdByte = cmdYellowBlink
	case StateGreen:
		cmdByte = cmdGreenBlink
	default:
		return fmt.Errorf("unsupported state: %s", state)
	}

	s, err := l.openPort()
	if err != nil {
		return err
	}
	defer func() {
		if err := s.Close(); err != nil {
			log.Printf("Error closing serial port: %s", err.Error())
		}
	}()

	return sendCommand(s, cmdByte)
}

func (l *SerialLight) Clear() error {
	s, err := l.openPort()
	if err != nil {
		return err
	}
	defer func() {
		if err := s.Close(); err != nil {
			log.Printf("Error closing serial port: %s", err.Error())
		}
	}()

	initialCommands := []byte{
		cmdBuzzerOff,
		cmdRedOff,
		cmdYellowOff,
		cmdGreenOff,
	}

	for _, cmd := range initialCommands {
		if err := sendCommand(s, cmd); err != nil {
			return err
		}
	}
	return nil
}

================
File: lights/traffic_light.go
================
package lights

import (
	"fmt"
	"log"

	"github.com/tarm/serial"
)

// TrafficLight implements Light interface for serial-based tower lights
type TrafficLight struct {
	port     string
	baudRate int
}

// NewTrafficLight creates a new TrafficLight instance
func NewTrafficLight(port string, baudRate int) *TrafficLight {
	return &TrafficLight{
		port:     port,
		baudRate: baudRate,
	}
}

func (l *TrafficLight) openPort() (*serial.Port, error) {
	c := &serial.Config{
		Name: l.port,
		Baud: l.baudRate,
	}
	return serial.OpenPort(c)
}

func (l *TrafficLight) On(cmd interface{}) error {
	state, ok := cmd.(StandardState)
	if !ok {
		return fmt.Errorf("invalid command type for TrafficLight")
	}

	// Maps the StandardState to corresponding command bytes for the traffic light.
	// Command bytes are defined in commands.go with the following values:
	// - cmdRedOn (0x11): Turns on the red light
	// - cmdYellowOn (0x12): Turns on the yellow light
	// - cmdGreenOn (0x14): Turns on the green light
	// These command bytes are specific to the hardware protocol used by the traffic light.
	var cmdByte byte
	switch state {
	case StateRed:
		cmdByte = cmdRedOn
	case StateYellow:
		cmdByte = cmdYellowOn
	case StateGreen:
		cmdByte = cmdGreenOn
	default:
		return fmt.Errorf("unsupported state: %s", state)
	}

	if err := l.Clear(); err != nil {
		return fmt.Errorf("failed to clear light state: %w", err)
	}

	s, err := l.openPort()
	if err != nil {
		return err
	}
	defer func() {
		if err := s.Close(); err != nil {
			log.Printf("Error closing serial port: %s", err.Error())
		}
	}()

	return sendCommand(s, cmdByte)
}

func (l *TrafficLight) Blink(cmd interface{}) error {
	state, ok := cmd.(StandardState)
	if !ok {
		return fmt.Errorf("invalid command type for TrafficLight")
	}

	var cmdByte byte
	switch state {
	case StateRed:
		cmdByte = cmdRedBlink
	case StateYellow:
		cmdByte = cmdYellowBlink
	case StateGreen:
		cmdByte = cmdGreenBlink
	default:
		return fmt.Errorf("unsupported state: %s", state)
	}

	s, err := l.openPort()
	if err != nil {
		return err
	}
	defer func() {
		if err := s.Close(); err != nil {
			log.Printf("Error closing serial port: %s", err.Error())
		}
	}()

	return sendCommand(s, cmdByte)
}

func (l *TrafficLight) Clear() error {
	s, err := l.openPort()
	if err != nil {
		return err
	}
	defer func() {
		if err := s.Close(); err != nil {
			log.Printf("Error closing serial port: %s", err.Error())
		}
	}()

	initialCommands := []byte{
		cmdBuzzerOff,
		cmdRedOff,
		cmdYellowOff,
		cmdGreenOff,
	}

	for _, cmd := range initialCommands {
		if err := sendCommand(s, cmd); err != nil {
			return err
		}
	}
	return nil
}

================
File: lights/utils.go
================
package lights

import (
	"fmt"

	"github.com/tarm/serial"
)

// sendCommand sends a command byte to the serial port
func sendCommand(port *serial.Port, cmd byte) error {
	_, err := port.Write([]byte{cmd})
	if err != nil {
		return fmt.Errorf("failed to send command: %w", err)
	}
	return nil
}

================
File: network/network.go
================
package network

import (
	"fmt"
	"net/http"
	"time"
)

const (
	connectivityCheck = "https://www.google.com"
	connectTimeout    = 10 * time.Second
)

// CheckConnectivity verifies internet connectivity by making a request to a known endpoint
func CheckConnectivity() error {
	client := &http.Client{
		Timeout: connectTimeout,
	}

	resp, err := client.Get(connectivityCheck)
	if err != nil {
		return fmt.Errorf("connectivity check failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("connectivity check failed with status code: %d", resp.StatusCode)
	}

	return nil
}

================
File: node/node.go
================
package node

import "os"

// GetNodeName retrieves the node name from environment variables
func GetNodeName() string {
	nodeName := os.Getenv("NODE_NAME")
	if nodeName == "" {
		nodeName = os.Getenv("HOSTNAME")
	}
	if nodeName == "" {
		nodeName = "unknown"
	}
	return nodeName
}

================
File: notify/notify.go
================
package notify

import (
	"fmt"
	"net/http"
	"strings"
)

const (
	notificationEndpoint = "https://ntfy.sh/dapidi_alerts"
)

// Send sends a notification message to the configured endpoint
func Send(message string) error {
	if message == "" {
		return fmt.Errorf("message cannot be empty")
	}
	payload := strings.NewReader(message)
	resp, err := http.Post(notificationEndpoint, "text/plain", payload)
	if err != nil {
		return fmt.Errorf("failed to send notification: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
	}

	return nil
}

================
File: poll/poll.go
================
package poll

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"sort"
	"strings"
	"time"

	"my-incident-checker/lights"
	"my-incident-checker/network"
	"my-incident-checker/types"
)

const (
	incidentsEndpoint = "https://status-api.joseserver.com/incidents/recent?count=10"
	pollInterval      = 5 * time.Second
)

// PollIncidents continuously monitors for incidents and updates the light status
func PollIncidents(startTime time.Time, light lights.Light, logger *types.Logger) {
	logger.InfoLog.Printf("Starting incident polling at %s", startTime.Format(time.RFC3339))
	fmt.Printf("*** Starting incident polling at %s\n", startTime.Format(time.RFC3339))

	notifiedIncidents := make(map[int]bool)
	seenIncidents := make(map[int]bool)

	for {
		if err := network.CheckConnectivity(); err != nil {
			logger.WarnLog.Printf("Internet connectivity issue: %s", err.Error())
			light.On(lights.StateYellow)
			time.Sleep(pollInterval)
			continue
		}

		incidents, err := fetchIncidents()
		if err != nil {
			logger.ErrorLog.Printf("Failed to fetch incidents: %s", err.Error())
			time.Sleep(pollInterval)
			continue
		}

		logger.DebugLog.Printf("Fetched %d incidents", len(incidents))

		for _, incident := range incidents {
			if !seenIncidents[incident.ID] {
				logger.InfoLog.Printf("New incident detected: [%s] %s - Current State: %s",
					incident.Service,
					incident.Incident.Title,
					incident.CurrentState)
				seenIncidents[incident.ID] = true
			}
		}

		// Log state changes
		state, err := AlertLogic(incidents, light, notifiedIncidents, startTime)
		if err != nil {
			logger.ErrorLog.Printf("Alert logic error: %s", err.Error())
		} else if state != nil {
			logger.InfoLog.Printf("Light state changed to: %T", state)
			if err := light.On(state); err != nil {
				logger.ErrorLog.Printf("Failed to apply light state: %s", err.Error())
			}
		}

		time.Sleep(pollInterval)
	}
}

// fetchIncidents retrieves the list of incidents from the API
func fetchIncidents() ([]types.Incident, error) {
	resp, err := http.Get(incidentsEndpoint)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch incidents: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code from incidents API: %d", resp.StatusCode)
	}

	const maxResponseSize = 1 << 20 // 1 MB
	body, err := io.ReadAll(io.LimitReader(resp.Body, maxResponseSize))
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var incidents []types.Incident
	if err := json.Unmarshal(body, &incidents); err != nil {
		return nil, fmt.Errorf("failed to parse incidents: %w", err)
	}

	return incidents, nil
}

// sortIncidentsByTime sorts incidents by creation time, most recent first
func sortIncidentsByTime(incidents []types.Incident) []types.Incident {
	sorted := make([]types.Incident, len(incidents))
	copy(sorted, incidents)

	sort.Slice(sorted, func(i, j int) bool {
		return sorted[i].CreatedAt > sorted[j].CreatedAt
	})

	return sorted
}

// AlertLogic determines the appropriate light state based on incident status
func AlertLogic(incidents []types.Incident, light lights.Light, notifiedIncidents map[int]bool, startTime time.Time) (lights.State, error) {
	if len(incidents) == 0 {
		return nil, nil
	}

	// Sort incidents by creation time, most recent first
	sortedIncidents := sortIncidentsByTime(incidents)
	mostRecent := sortedIncidents[0]

	// First check the most recent incident
	createdAt, err := parseIncidentTime(mostRecent)
	if err != nil {
		return lights.YellowState{}, fmt.Errorf("error parsing incident time: %s", err.Error())
	}

	if createdAt.After(startTime) && isNormalState(mostRecent.CurrentState) {
		fmt.Printf("Notification not sent for incident: %s [%s]\n", mostRecent.Incident.Title, mostRecent.CurrentState)
		return lights.GreenState{}, nil
	}

	// Then check for any unnotified critical incidents
	for _, incident := range sortedIncidents {
		createdAt, err := parseIncidentTime(incident)
		if err != nil {
			return lights.YellowState{}, fmt.Errorf("error parsing incident time: %s", err.Error())
		}

		if !createdAt.After(startTime) {
			continue
		}

		if !notifiedIncidents[incident.ID] && isRelevantState(incident.CurrentState) {
			notifiedIncidents[incident.ID] = true
			return lights.RedState{}, nil
		}
	}

	return nil, nil
}

// parseIncidentTime parses the incident creation time
func parseIncidentTime(incident types.Incident) (time.Time, error) {
	return time.Parse(types.TimeFormat, strings.Split(incident.CreatedAt, ".")[0])
}

// isNormalState checks if the state is operational or maintenance
func isNormalState(state string) bool {
	return state == types.StateOperational || state == types.StateMaintenance
}

// isRelevantState checks if the state is critical, outage, or degraded
func isRelevantState(state string) bool {
	return state == types.StateCritical || state == types.StateOutage || state == types.StateDegraded
}

================
File: types/types.go
================
package types

import "log"

// Log levels
const (
	LogDebug = "DEBUG"
	LogInfo  = "INFO"
	LogWarn  = "WARN"
	LogError = "ERROR"
)

const (
	TimeFormat = "2006-01-02T15:04:05.999999"

	StateOperational = "operational"
	StateMaintenance = "maintenance"
	StateCritical    = "critical"
	StateOutage      = "outage"
	StateDegraded    = "degraded"
)

type Logger struct {
	DebugLog *log.Logger
	InfoLog  *log.Logger
	WarnLog  *log.Logger
	ErrorLog *log.Logger
}

type IncidentDetails struct {
	Title       string   `json:"title"`
	Description string   `json:"description"`
	Components  []string `json:"components"`
	URL         string   `json:"url"`
}

type IncidentHistory struct {
	ID           int             `json:"id"`
	IncidentID   int             `json:"incident_id"`
	RecordedAt   string          `json:"recorded_at"`
	Service      string          `json:"service"`
	PrevState    string          `json:"previous_state"`
	CurrentState string          `json:"current_state"`
	Incident     IncidentDetails `json:"incident"`
}

type Incident struct {
	ID           int               `json:"id"`
	Service      string            `json:"service"`
	PrevState    string            `json:"previous_state"`
	CurrentState string            `json:"current_state"`
	CreatedAt    string            `json:"created_at"`
	Incident     IncidentDetails   `json:"incident"`
	History      []IncidentHistory `json:"history"`
}

================
File: .gitignore
================
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
vendor/

# Go workspace file
go.work

# Binary output
my-incident-checker*

# Release directory
release/

.aider*

================
File: .python-version
================
3.12.7

================
File: go.mod
================
module my-incident-checker

go 1.18

require github.com/tarm/serial v0.0.0-20180830185346-98f6abe2eb07

require (
	github.com/todbot/blink1 v0.1.0
	golang.org/x/sys v0.29.0 // indirect
)

================
File: go.sum
================
github.com/tarm/serial v0.0.0-20180830185346-98f6abe2eb07 h1:UyzmZLoiDWMRywV4DUYb9Fbt8uiOSooupjTq10vpvnU=
github.com/tarm/serial v0.0.0-20180830185346-98f6abe2eb07/go.mod h1:kDXzergiv9cbyO7IOYJZWg1U88JhDg3PB6klq9Hg2pA=
golang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=
golang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=

================
File: light.go
================
package main

import (
	"log"

	"github.com/tarm/serial"
)

const (
	serialPort = "/dev/ttyUSB0" // Change to the serial/COM port of the tower light
	baudRate   = 9600

	// Command bytes for LEDs and buzzer
	RED_ON    byte = 0x11
	RED_OFF   byte = 0x21
	RED_BLINK byte = 0x41

	YELLOW_ON    byte = 0x12
	YELLOW_OFF   byte = 0x22
	YELLOW_BLINK byte = 0x42

	GREEN_ON    byte = 0x14
	GREEN_OFF   byte = 0x24
	GREEN_BLINK byte = 0x44

	BUZZER_ON    byte = 0x18
	BUZZER_OFF   byte = 0x28
	BUZZER_BLINK byte = 0x48
)

type TrafficLight struct{}

type LightState interface {
	Apply(light *TrafficLight) error
}

type RedLight struct{}
type GreenLight struct{}
type YellowLight struct{}

func (s RedLight) Apply(light *TrafficLight) error {
	return light.On(RED_ON)
}

func (s GreenLight) Apply(light *TrafficLight) error {
	return light.On(GREEN_ON)
}

func (s YellowLight) Apply(light *TrafficLight) error {
	return light.On(YELLOW_ON)
}

func (l *TrafficLight) On(onCmd byte) error {
	l.Clear()

	// Configure serial port settings
	c := &serial.Config{
		Name: serialPort,
		Baud: baudRate,
	}

	// Open the serial port
	s, err := serial.OpenPort(c)
	if err != nil {
		return err
	}
	defer func() {
		if err := s.Close(); err != nil {
			log.Printf("Error closing serial port: %s", err.Error())
		}
	}()

	if err := sendCommand(s, onCmd); err != nil {
		return err
	}
	return nil
}

func (l *TrafficLight) Clear() error {
	// Configure serial port settings
	c := &serial.Config{
		Name: serialPort,
		Baud: baudRate,
	}

	// Open the serial port
	s, err := serial.OpenPort(c)
	if err != nil {
		return err
	}
	defer func() {
		if err := s.Close(); err != nil {
			log.Printf("Error closing serial port: %s", err.Error())
		}
	}()

	// Clean up any old state by turning off all LEDs and buzzer
	initialCommands := []byte{
		BUZZER_OFF,
		RED_OFF,
		YELLOW_OFF,
		GREEN_OFF,
	}

	for _, cmd := range initialCommands {
		if err := sendCommand(s, cmd); err != nil {
			return err
		}
	}
	return nil
}

func sendCommand(port *serial.Port, cmd byte) error {
	_, err := port.Write([]byte{cmd})
	return err
}

================
File: main_test.go
================
package main

import (
	"reflect"
	"testing"
	"time"

	"my-incident-checker/lights"
	"my-incident-checker/poll"
	"my-incident-checker/types"
)

// MockLight implements lights.Light interface for testing
type MockLight struct{}

func (l *MockLight) On(cmd interface{}) error    { return nil }
func (l *MockLight) Clear() error                { return nil }
func (l *MockLight) Blink(cmd interface{}) error { return nil }

func TestAlertLogic(t *testing.T) {
	startTime := time.Date(2025, 1, 9, 3, 17, 41, 0, time.UTC)
	light := &MockLight{}

	tests := []struct {
		name              string
		incidents         []types.Incident
		notifiedIncidents map[int]bool
		startTime         time.Time
		wantState         lights.State
		wantErr           bool
	}{
		{
			name: "new critical incident",
			incidents: []types.Incident{
				{
					ID:           1,
					Service:      "api",
					CurrentState: "critical",
					CreatedAt:    "2025-01-09T03:18:00",
					Incident: types.IncidentDetails{
						Title:       "API Down",
						Description: "API is not responding",
					},
				},
			},
			notifiedIncidents: map[int]bool{},
			startTime:         startTime,
			wantState:         lights.RedState{},
			wantErr:           false,
		},
		{
			name: "already notified incident",
			incidents: []types.Incident{
				{
					ID:           1,
					Service:      "api",
					CurrentState: "critical",
					CreatedAt:    "2025-01-09T03:18:00",
					Incident: types.IncidentDetails{
						Title:       "API Down",
						Description: "API is not responding",
					},
				},
			},
			notifiedIncidents: map[int]bool{1: true},
			startTime:         startTime,
			wantState:         nil,
			wantErr:           false,
		},
		{
			name: "old incident",
			incidents: []types.Incident{
				{
					ID:           1,
					Service:      "api",
					CurrentState: "critical",
					CreatedAt:    "2025-01-09T03:16:00",
					Incident: types.IncidentDetails{
						Title:       "API Down",
						Description: "API is not responding",
					},
				},
			},
			notifiedIncidents: map[int]bool{},
			startTime:         startTime,
			wantState:         nil,
			wantErr:           false,
		},
		{
			name: "operational state",
			incidents: []types.Incident{
				{
					ID:           1,
					Service:      "api",
					CurrentState: "operational",
					CreatedAt:    "2025-01-09T03:18:00",
					Incident: types.IncidentDetails{
						Title:       "API Recovered",
						Description: "API is back online",
					},
				},
			},
			notifiedIncidents: map[int]bool{},
			startTime:         startTime,
			wantState:         lights.GreenState{},
			wantErr:           false,
		},
		{
			name: "maintenance state",
			incidents: []types.Incident{
				{
					ID:           1,
					Service:      "api",
					CurrentState: "maintenance",
					CreatedAt:    "2025-01-09T03:18:00",
					Incident: types.IncidentDetails{
						Title:       "API Maintenance",
						Description: "Scheduled maintenance",
					},
				},
			},
			notifiedIncidents: map[int]bool{},
			startTime:         startTime,
			wantState:         lights.GreenState{},
			wantErr:           false,
		},
		{
			name: "multiple incidents - most recent critical",
			incidents: []types.Incident{
				{
					ID:           1,
					Service:      "api",
					CurrentState: "operational",
					CreatedAt:    "2025-01-09T03:18:00",
					Incident: types.IncidentDetails{
						Title:       "API Recovered",
						Description: "API is back online",
					},
				},
				{
					ID:           2,
					Service:      "database",
					CurrentState: "critical",
					CreatedAt:    "2025-01-09T03:19:00",
					Incident: types.IncidentDetails{
						Title:       "Database Down",
						Description: "Database not responding",
					},
				},
			},
			notifiedIncidents: map[int]bool{},
			startTime:         startTime,
			wantState:         lights.RedState{},
			wantErr:           false,
		},
		{
			name: "multiple incidents - most recent operational",
			incidents: []types.Incident{
				{
					ID:           1,
					Service:      "database",
					CurrentState: "critical",
					CreatedAt:    "2025-01-09T03:18:00",
					Incident: types.IncidentDetails{
						Title:       "Database Down",
						Description: "Database not responding",
					},
				},
				{
					ID:           2,
					Service:      "api",
					CurrentState: "operational",
					CreatedAt:    "2025-01-09T03:19:00",
					Incident: types.IncidentDetails{
						Title:       "API Recovered",
						Description: "API is back online",
					},
				},
			},
			notifiedIncidents: map[int]bool{},
			startTime:         startTime,
			wantState:         lights.GreenState{},
			wantErr:           false,
		},
		{
			name: "invalid time format",
			incidents: []types.Incident{
				{
					ID:           1,
					Service:      "api",
					CurrentState: "critical",
					CreatedAt:    "invalid-time",
					Incident: types.IncidentDetails{
						Title:       "API Down",
						Description: "API is not responding",
					},
				},
			},
			notifiedIncidents: map[int]bool{},
			startTime:         startTime,
			wantState:         lights.YellowState{},
			wantErr:           true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotState, err := poll.AlertLogic(tt.incidents, light, tt.notifiedIncidents, tt.startTime)

			if (err != nil) != tt.wantErr {
				t.Errorf("AlertLogic() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if (gotState == nil) != (tt.wantState == nil) {
				t.Errorf("AlertLogic() got state = %v, want state = %v", gotState, tt.wantState)
				return
			}

			if gotState != nil {
				gotType := reflect.TypeOf(gotState)
				wantType := reflect.TypeOf(tt.wantState)
				if gotType != wantType {
					t.Errorf("AlertLogic() got state type = %v, want state type = %v", gotType, wantType)
				}
			}
		})
	}
}

================
File: main.go
================
package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	"my-incident-checker/heartbeat"
	"my-incident-checker/lights"
	"my-incident-checker/network"
	"my-incident-checker/node"
	"my-incident-checker/notify"
	"my-incident-checker/poll"
	"my-incident-checker/types"
)

func NewLogger() (*types.Logger, error) {
	// Create logs directory if it doesn't exist
	logDir := "logs"
	if err := os.MkdirAll(logDir, 0755); err != nil {
		return nil, err
	}

	// Create or append to log file with timestamp
	currentTime := time.Now().Format("2006-01-02")
	logFile := filepath.Join(logDir, "incident-checker-"+currentTime+".log")
	file, err := os.OpenFile(logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return nil, err
	}

	// Create multi-writer for both file and stdout
	flags := log.LstdFlags | log.Lmicroseconds | log.LUTC

	return &types.Logger{
		DebugLog: log.New(file, "DEBUG: ", flags),
		InfoLog:  log.New(file, "INFO:  ", flags),
		WarnLog:  log.New(file, "WARN:  ", flags),
		ErrorLog: log.New(file, "ERROR: ", flags),
	}, nil
}

func main() {
	logger, err := NewLogger()
	if err != nil {
		log.Fatalf("Failed to initialize logger: %s", err.Error())
	}

	// Add deferred exit log message
	defer logger.InfoLog.Printf("Program shutting down")

	logger.InfoLog.Printf("Starting Incident Checker")

	// Check initial connectivity
	if err := network.CheckConnectivity(); err != nil {
		logger.WarnLog.Printf("Initial connectivity check failed: %s", err.Error())
		logger.InfoLog.Printf("Will continue and retry during polling...")
	} else {
		logger.InfoLog.Printf("Internet connectivity confirmed")
	}

	nodeName := node.GetNodeName()
	startupMessage := fmt.Sprintf("%s is online", nodeName)

	if err := notify.Send(startupMessage); err != nil {
		log.Fatal(err)
	}
	fmt.Println("Startup notification sent successfully")

	// Initialize the light with automatic detection
	light, cleanup, err := initializeLight(logger)
	if err != nil {
		log.Fatal(err)
	}
	defer cleanup()

	light.Clear()

	fmt.Println("Yellow light on for 2 seconds")
	light.Blink(lights.StateYellow)
	time.Sleep(2 * time.Second)

	fmt.Println("Red light on for 2 seconds")
	light.Blink(lights.StateRed)
	time.Sleep(2 * time.Second)

	fmt.Println("Green light on for 2 seconds")
	light.Blink(lights.StateGreen)
	time.Sleep(2 * time.Second)

	light.Clear()
	fmt.Println("Lights cleared")
	light.On(lights.StateGreen)

	// Start heartbeat in a goroutine
	fmt.Println("Starting heartbeat")
	logger.InfoLog.Printf("Starting heartbeat...")
	go heartbeat.Run()

	fmt.Println("Polling for incidents")
	startTime := time.Now()
	poll.PollIncidents(startTime, light, logger)
	fmt.Println("Stopped polling for incidents")
}

func initializeLight(logger *types.Logger) (lights.Light, func(), error) {
	// Try to initialize BLINK1MK3 first
	if blink1Light, err := lights.NewBlink1Light(); err == nil {
		fmt.Println("Using BLINK1MK3 light")
		logger.InfoLog.Printf("Using BLINK1MK3 light")
		return blink1Light, func() {
			blink1Light.Close()
		}, nil
	}

	// Fall back to SerialLight
	fmt.Println("BLINK1MK3 not found, using SerialLight")
	logger.InfoLog.Printf("BLINK1MK3 not found, using SerialLight")
	serialLight := lights.NewSerialLight("/dev/ttyUSB0", 9600)
	return serialLight, func() {}, nil
}

================
File: Makefile
================
.PHONY: build build-arm build-amd32 all clean release

VERSION ?= $(shell git describe --tags --always --dirty)
RELEASE_DIR = release

# Default build for current architecture
build: build-arm build-amd32
	go build -o my-incident-checker

# Build for ARM (e.g., Raspberry Pi)
build-arm:
	GOOS=linux GOARCH=arm go build -o my-incident-checker-arm

# Build for 32-bit AMD/Intel
build-amd32:
	GOOS=linux GOARCH=386 go build -o my-incident-checker-386

test:
	go test ./...

# Clean build artifacts
clean:
	rm -f my-incident-checker*
	rm -rf $(RELEASE_DIR)

# Prepare release artifacts
release: clean build
	mkdir -p $(RELEASE_DIR)
	cp my-incident-checker $(RELEASE_DIR)/my-incident-checker-$(VERSION)
	cp my-incident-checker-arm $(RELEASE_DIR)/my-incident-checker-arm-$(VERSION)
	cp my-incident-checker-386 $(RELEASE_DIR)/my-incident-checker-386-$(VERSION)
	cd $(RELEASE_DIR) && \
		tar czf my-incident-checker-$(VERSION).tar.gz my-incident-checker-* && \
		sha256sum my-incident-checker-$(VERSION).tar.gz > my-incident-checker-$(VERSION).sha256

# Build all architectures
all: build build-arm build-amd32

================
File: README.md
================
# Incident Checker

A watcher for service incidents.
A Go-based monitoring application that checks for service incidents and sends notifications via ntfy.sh.

![image](image.jpg)

## Purpose

This application monitors a status API for service incidents and:
- Sends notifications when new incidents are detected in "outage" or "degraded" state
- Prevents duplicate notifications for the same incident
- Monitors internet connectivity
- Runs continuously with configurable polling intervals

## Features

- Startup notification with node identification
- Periodic incident polling (every 60 seconds)
- Internet connectivity monitoring
- Incident state filtering (outage/degraded)
- Duplicate notification prevention
- Multi-architecture support

## Requirements

- Go 1.x
- Make (for building)
- Internet connectivity
- Environment Variables:
  - `NODE_NAME`: Custom node identifier (optional)
  - `HOSTNAME`: Fallback node identifier (optional)

## Building

The project includes a Makefile with several build targets:

```bash
# Build for current architecture
make build

# Build for ARM (e.g., Raspberry Pi)
make build-arm

# Build for 32-bit x86
make build-amd32

# Build all architectures
make all
```

Output binaries:
- `my-incident-checker` (native)
- `my-incident-checker-arm` (ARM)
- `my-incident-checker-386` (32-bit x86)

## Running

1. Build the application for your architecture:
```bash
make build
```

2. Run with a node name:
```bash
NODE_NAME=my-node ./my-incident-checker
```

The application will:
1. Check internet connectivity
2. Send a startup notification
3. Begin polling for incidents
4. Send notifications for new outages or degraded services

## Monitoring

The application logs:
- Startup status
- Connectivity issues
- Polling errors
- Notification delivery status

## Architecture

- Uses standard Go libraries
- HTTP-based communication
- In-memory incident tracking
- Configurable endpoints and intervals
